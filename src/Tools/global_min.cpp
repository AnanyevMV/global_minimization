#include "Tools/global_min.hpp"
#include <array>
#include <niederreiter2.hpp>
#include "Tools/thread_pool.h"
#include <chrono>

std::vector<std::vector<IterationData> >
find_local_mins_with_threads(Function f, const StopCondition& stop_condition,
                             const std::vector<std::pair<Real, Vector>>& inData) {


    static const std::array<std::function<IterationData(Function, Vector, const StopCondition&)>, 18> min_funcs{
            &Adadelta,&Adagrad,&Adam, &AdaMax, &AdamW, &AMSGrad, &bfgs, (IterationData (*)(Function, Vector, const StopCondition&))bfgs2,
            &dfp, &dfp2, &hessian_free, &slow_hessian_free, &Nadam,
            &nesterov, &powell, &powell2, &powell21, &RmsProp
    };

    // Создаем вектор под ответ
    std::vector<std::vector<IterationData> > outData(inData.size(), std::vector<IterationData>(min_funcs.size() + 1));

    // Количество потоков
    const uint32_t cores = ThreadPool::GetHardwareCoresAmount();

    // Создаем пул потоков
    ThreadPool thread_pool{cores};

    for (size_t i = 0; i < inData.size(); ++i) {
        // Записываем начальное значение
        outData[i][0] = IterationData{inData[i].second, inData[i].first, inData[i].second,inData[i].first,inData[i].second,inData[i].first, 0, "Point generated by tms-net"};

        for (size_t j = 0; j < min_funcs.size(); ++j) {
            thread_pool.Add([&, i, j](){
					outData[i][j+1] = min_funcs[j](f, inData[i].second, stop_condition);
                }
            );
        }
    }
    thread_pool.CreateThreads();
    thread_pool.WaitForAll();
    return outData;
}

/**
 * \brief Меняет очереди местами (оба мьютекса должны быть залочены перед вызовом)
 * \tparam T producerArgs или consumerArgs
 * \param argsStruct Указатель на структуру аргументов
 * \param writeQueueEmpty [out, optional] Указывает, является ли writeQueue пустой очередью после обмена
 * \return false - если обе очереди пустые, иначе - true
 */
template <typename T>
bool SwapQueues(T* argsStruct, bool* writeQueueEmpty = nullptr) {
    bool result = true;

    if (argsStruct->writeQueue.empty() && argsStruct->readQueue.empty()) {
        result = false;
    }
    else {
        // Меняем очереди местами
        std::swap(argsStruct->writeQueue, argsStruct->readQueue);
    }

    if (writeQueueEmpty)
        *writeQueueEmpty = argsStruct->writeQueue.empty();

    return result;
}

/**
 * \brief Проверяет, являются ли обе очереди пустыми
 * \tparam T producerArgs или consumerArgs
 * \param argsStruct Указатель на структуру аргументов
 * \param lockProducer Нужно ли лочить поставщика
 * \return true - если обе очереди пустые, иначе - false
 */
template <typename T>
bool AreQueuesEmpty(T* argsStruct) {
    const bool result = argsStruct->writeQueue.empty() && argsStruct->readQueue.empty();
    return result;
}

/**
 * \brief Проверяет, являются ли обе очереди полными
 * \tparam T producerArgs или consumerArgs
 * \param argsStruct Указатель на структуру аргументов
 * \param lockProducer Нужно ли лочить поставщика
 * \return true - если обе очереди полные, иначе - false
 */
template <typename T>
bool AreQueuesFull(T* argsStruct) {
    const bool result = argsStruct->writeQueue.size() >= argsStruct->maxQueueSize && argsStruct->readQueue.size() >= argsStruct->maxQueueSize;
    return result;
}

// Поток потребитель
void* calc_f_with_threads(void* args) {
    volatile consumerArgs* consArgs = static_cast<consumerArgs*>(args);

    while (true) {
        pthread_mutex_lock(&consArgs->consumerMutex);

        if (consArgs->readQueue.empty()) {
            pthread_mutex_lock(&consArgs->producerMutex);

            bool isWriteQueueEmpty;
            const bool result = SwapQueues(consArgs, &isWriteQueueEmpty);

            // Если очередь поставщика пуста (после свапа), то сигналим ему
            if (isWriteQueueEmpty) {
                pthread_cond_signal(&consArgs->canProduce);
            }

            // Если обмен был неуспешным (обе очереди пусты)
            if (!result) {
                // Проверяем, будут ли еще элементы
                if (consArgs->endOfGeneration) {
                    // Если нет, то выходим из цикла (и из функции)
                    pthread_mutex_unlock(&consArgs->producerMutex);
                    pthread_mutex_unlock(&consArgs->consumerMutex);
                    break;
                }

                //  Если будут, то ждем
                while (AreQueuesEmpty(consArgs)) {
                    if (consArgs->endOfGeneration)
                        break;
                    consArgs->producerCanSignal = true;
                    pthread_mutex_unlock(&consArgs->producerMutex);
                    pthread_cond_wait(&consArgs->canConsume, &consArgs->consumerMutex);
                    pthread_mutex_lock(&consArgs->producerMutex);
                }
                pthread_mutex_unlock(&consArgs->producerMutex);
                // В идеале, анлочить его не нужно здесь
                // А то там он в цикле снова захватится
                pthread_mutex_unlock(&consArgs->consumerMutex);
                continue;
            }

            pthread_mutex_unlock(&consArgs->producerMutex);
        }

        // Берем элемент из очереди
        Vector point = consArgs->readQueue.front();
        consArgs->readQueue.pop();

        pthread_mutex_unlock(&consArgs->consumerMutex);

        // Выполняем функцию
        auto res = consArgs->f(point);

        // Сохраняем результат

        pthread_mutex_lock(&consArgs->writeMutex);

        consArgs->candidates.emplace(res, point);
        if (consArgs->candidates.size() > consArgs->nBestPoints) {
            consArgs->candidates.erase(std::prev(consArgs->candidates.end()));
        }

        pthread_mutex_unlock(&consArgs->writeMutex);
    }

    pthread_exit(nullptr);

    return nullptr;
}

// Функция для треда-поставщика
void* add_points_to_queue(void* args) {
    volatile producerArgs* ptrProducerArgs = static_cast<producerArgs*>(args);
    // Создаем генератор
    using GeneratorType = sequences::Niederreiter<uint64_t, 64>;
    GeneratorType generator(ptrProducerArgs->dim);
    // Счетчик
    uint32_t counter = 0;
    // Генерируем первую точку
    // Генератор генерирует быстрее, если указать предыдущую точку
    // Поэтому сгенерируем первую точку и будем хранить в переменной curr_int_point
    // каждый раз предыдущую точку и через неё быстрее получать следующую
    GeneratorType::IntPoint curr_int_point = generator.get_point_int(counter);
    Vector v0 = GeneratorType::cast_point_int_to_real(curr_int_point);
    for (unsigned int i = 0; i < ptrProducerArgs->dim; ++i) {
        // Приводим точку на единичном s-мерном кубе к точке в s-мерном прямоугольном параллелепипеде
        v0[i] = v0[i] * (ptrProducerArgs->max[i] - ptrProducerArgs->min[i]) + ptrProducerArgs->min[i];
    }
    pthread_mutex_lock(&ptrProducerArgs->producerMutex);

    ptrProducerArgs->writeQueue.emplace(v0);

    pthread_mutex_unlock(&ptrProducerArgs->producerMutex);
    ++counter;


    while (true) {
        bool at_endOfGeneration = false;
        pthread_mutex_lock(&ptrProducerArgs->producerMutex);
        if (counter < ptrProducerArgs->nAllPoints) {
            uint32_t howManyPoints = std::min((uint32_t)ptrProducerArgs->miniBatchSize, ptrProducerArgs->nAllPoints - counter);
            for (uint32_t k = 0; k < howManyPoints; k++){
                // Генерируем новую точку
                generator.store_next_point_int(curr_int_point, counter, curr_int_point);
                // Сохраняем точку
                ptrProducerArgs->writeQueue.emplace(GeneratorType::cast_point_int_to_real(curr_int_point));
                for (unsigned int i = 0; i < ptrProducerArgs->dim; ++i) {
                    // Приводим точку на единичном s-мерном кубе к точке в s-мерном прямоугольном параллелепипеде
                    ptrProducerArgs->writeQueue.back()[i] = ptrProducerArgs->writeQueue.back()[i] * (ptrProducerArgs->max[i] - ptrProducerArgs->min[i]) + ptrProducerArgs->min[i];
                }
                ++counter;
            }
            // Если есть спящие треды, то сигналим тредам-потребителям, что в очереди появились элементы
            if (ptrProducerArgs->producerCanSignal) {
                // Предотвращаем deadlock
                pthread_mutex_unlock(&ptrProducerArgs->producerMutex);

                // Лочим в правильном порядке
                pthread_mutex_lock(&ptrProducerArgs->consumerMutex);
                pthread_mutex_lock(&ptrProducerArgs->producerMutex);

                ptrProducerArgs->producerCanSignal = false;
                pthread_cond_broadcast(&ptrProducerArgs->canConsume);

                pthread_mutex_unlock(&ptrProducerArgs->consumerMutex);
            }

        }
        else {
            at_endOfGeneration = true;
        }

        if (ptrProducerArgs->writeQueue.size() >= ptrProducerArgs->maxQueueSize || at_endOfGeneration) {
            // Лочим мьютекс в правильном порядке, чтоб предотвратить deadlock
            pthread_mutex_unlock(&ptrProducerArgs->producerMutex);
            pthread_mutex_lock(&ptrProducerArgs->consumerMutex);
            pthread_mutex_lock(&ptrProducerArgs->producerMutex);
            // Обновим endOfGeneration
            ptrProducerArgs->endOfGeneration = at_endOfGeneration;
            // Если больше точек не будет, то сигналим всем потребителям (на случай если они спят)
            if (at_endOfGeneration) {
                pthread_cond_broadcast(&ptrProducerArgs->canConsume);
            }
            // Если обе очереди полные
            while (AreQueuesFull(ptrProducerArgs)) {
                pthread_mutex_unlock(&ptrProducerArgs->consumerMutex);
                // Ожидаем
                pthread_cond_wait(&ptrProducerArgs->canProduce, &ptrProducerArgs->producerMutex);
                // Чтобы предотвратить возможный deadlock
                pthread_mutex_unlock(&ptrProducerArgs->producerMutex);
                // Мы лочим в одинаковом порядке, как и треды-потребители
                // Иначе может быть deadlock
                pthread_mutex_lock(&ptrProducerArgs->consumerMutex);
                pthread_mutex_lock(&ptrProducerArgs->producerMutex);
            }
            // Меняем очереди местами
            SwapQueues(ptrProducerArgs);
            pthread_mutex_unlock(&ptrProducerArgs->producerMutex);
            pthread_mutex_unlock(&ptrProducerArgs->consumerMutex);
            // Если элементов больше нет, то выходим
            if (at_endOfGeneration) {
                break;
            }
        } else {
            pthread_mutex_unlock(&ptrProducerArgs->producerMutex);
        }
    }

    pthread_exit(nullptr);

    return nullptr;
}


GlobalMinimizationResults
find_absmin(Function f, const StopCondition& stop_condition, uint32_t dim, uint32_t nBestPoints, uint32_t nAllPoints,
        uint32_t miniBatchSize, uint32_t maxQueueSize, const Vector& min, const Vector& max,uint32_t HowManyConsumers, bool checkBorders) {
    // Несколько проверок на входные данные:
    assert(dim > 0u && dim == min.size() && dim == max.size());
    assert(nBestPoints <= nAllPoints && nBestPoints > 0u);
    for (uint32_t i = 0; i < dim; ++i) {
        assert(min[i] <= max[i]);
    }
    std::cout << "\nFirst stage: finding n best points" << std::endl;
    auto start = std::chrono::steady_clock::now();

    // Создаем 2 очереди
    std::queue<Vector> readQueue;
    std::queue<Vector> writeQueue;

    // Мьютекс потребителей
    pthread_mutex_t consumerMutex;
    pthread_mutex_init(&consumerMutex, nullptr);

    // Мьютекс поставщика
    pthread_mutex_t producerMutex;
    pthread_mutex_init(&producerMutex, nullptr);

    // Мьютекс для потребителей для записи результатов
    pthread_mutex_t writeMutex;
    pthread_mutex_init(&writeMutex, nullptr);

    // Условная переменная "можно производить"
    pthread_cond_t canProduce;
    pthread_cond_init(&canProduce, nullptr);

    // Условная переменная "можно потреблять"
    pthread_cond_t canConsume;
    pthread_cond_init(&canConsume, nullptr);

    // Формирование списка лучших кандидатов
    std::set<std::pair<Real, Vector>> candidates;

    // bool переменная, отвечающая за то, закончилась ли генерация точек
    bool endOfGeneration = false;

    bool producerCanSignal = false;

    pthread_t producer;

    // Создаем экземпляр структуры аргументов поставщика
    producerArgs producer_args{
        readQueue, writeQueue, consumerMutex, producerMutex, canProduce, canConsume,
        endOfGeneration, producerCanSignal, min, max, dim, nAllPoints, miniBatchSize, maxQueueSize
    };

    // Создаем экземпляр структуры аргументов потребителя
    consumerArgs consumer_args{
        readQueue, writeQueue, consumerMutex, producerMutex, canProduce, canConsume, endOfGeneration,
        producerCanSignal, writeMutex, candidates, f, nBestPoints
    };

    pthread_create(&producer, nullptr, &add_points_to_queue, static_cast<void*>(&producer_args));

    // Вектор идентификаторов тредов-потребителей
    std::vector<pthread_t> vectOfConsumersTids(HowManyConsumers);

    for (uint32_t i = 0; i < HowManyConsumers; ++i) {
        pthread_t tid;
        pthread_create(&tid, nullptr, &calc_f_with_threads, static_cast<void*>(&consumer_args));
        vectOfConsumersTids.push_back(tid);
    }

    pthread_join(producer, nullptr);

    for (auto tid : vectOfConsumersTids) {
        pthread_join(tid, nullptr);
    }

    auto end = std::chrono::steady_clock::now();
    auto diff = end - start;
    std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl;
    std::cout << "\nSecond stage: launching minimization methods" << std::endl;

    // Структура под ответ
    GlobalMinimizationResults results;
    start = std::chrono::steady_clock::now();
    // ----- Второй этап: запуск алгоритмов поиска локального минимума из выбранных точек -----
    // Подготовка (перекладываем точки из set в vector - возможен рост скорости при последовательном размещении в памяти точек):
    std::vector<std::pair<Real, Vector>> temp(candidates.begin(), candidates.end());
    // Многопоточная обработка кандидатов:
    results.AllResults = find_local_mins_with_threads(f, stop_condition, temp);
    end = std::chrono::steady_clock::now();
    diff = end - start;
    std::cout << std::chrono::duration <double, std::milli>(diff).count() << " ms" << std::endl << std::endl;
    // Начальное значение
    results.GlobalMinimum = results.AllResults[0][0];
    results.BestMethodForEachPoint = std::vector<IterationData>(results.AllResults.size());
    // Начальные значения
    for (size_t i = 0; i < results.BestMethodForEachPoint.size(); ++i){
        results.BestMethodForEachPoint[i] = results.AllResults[i][0];
    }
    results.BestPointForEachMethod = std::vector<IterationData>(results.AllResults[0].size());
    // Начальные значения
    for (size_t i = 0; i < results.BestPointForEachMethod.size(); ++i){
        results.BestPointForEachMethod[i] = results.AllResults[0][i];
        // Есть вероятность, что первоначальная выбранная структура будет содержать NaN
        // Необходимо проверить это и выбрать структуру без NaN
        // Может теоретически получиться так, что метод для всех лучших точек сойдётся к NaN
        // Тут уже ничего не поделаешь, оставляем значение с NaN. Все вопросы к методу минимизации.
        for (size_t j = 0; j < results.AllResults.size(); ++j){
            if (!std::isnan(results.AllResults[j][i].f_curr)){
                results.BestPointForEachMethod[i] = results.AllResults[j][i];
                break;
            }
        }
    }
    // Проверяем на границы, если нужно
    if (checkBorders){

        size_t ilength = results.AllResults.size();
        size_t jlength = results.AllResults[0].size();
        for (size_t i = 0; i < ilength; ++i){
            for (size_t j = 0; j < jlength; ++j){
                // Если мы вышли за границы или метод минимизации почему-то вернул NaN, то флаг будет False
                bool BorderOrNaNFlag = true;
                size_t pointLength = results.AllResults[i][j].x_curr.size();
                for (size_t k = 0; k < pointLength; k++){
                    if (min[k] > results.AllResults[i][j].x_curr[k] || results.AllResults[i][j].x_curr[k] > max[k] || std::isnan(results.AllResults[i][j].x_curr[k])){
                        BorderOrNaNFlag = false;
                        break;
                    }
                }
                if (!std::isnan(results.AllResults[i][j].f_curr)){
                    if (BorderOrNaNFlag && results.GlobalMinimum.f_curr > results.AllResults[i][j].f_curr){
                        results.GlobalMinimum = results.AllResults[i][j];
                    }

                    if (BorderOrNaNFlag && results.BestPointForEachMethod[j].f_curr > results.AllResults[i][j].f_curr){
                        results.BestPointForEachMethod[j] = results.AllResults[i][j];
                    }

                    if (BorderOrNaNFlag && results.BestMethodForEachPoint[i].f_curr > results.AllResults[i][j].f_curr){
                        results.BestMethodForEachPoint[i] = results.AllResults[i][j];
                    }
                }
            }
        }
        return results;

    } else {
        size_t ilength = results.AllResults.size();
        size_t jlength = results.AllResults[0].size();
        for (size_t i = 0; i < ilength; ++i){
            for (size_t j = 0; j < jlength; ++j){
                // Если метод минимизации почему-то вернул NaN, то флаг будет False
                bool NaNFlag = true;
                size_t pointLength = results.AllResults[i][j].x_curr.size();
                for (size_t k = 0; k < pointLength; k++){
                    if (std::isnan(results.AllResults[i][j].x_curr[k])){
                        NaNFlag = false;
                        break;
                    }
                }
                if (!std::isnan(results.AllResults[i][j].f_curr)){
                    if (NaNFlag && results.GlobalMinimum.f_curr > results.AllResults[i][j].f_curr){
                        results.GlobalMinimum = results.AllResults[i][j];
                    }

                    if (NaNFlag && results.BestPointForEachMethod[j].f_curr > results.AllResults[i][j].f_curr){
                        results.BestPointForEachMethod[j] = results.AllResults[i][j];
                    }

                    if (NaNFlag && results.BestMethodForEachPoint[i].f_curr > results.AllResults[i][j].f_curr){
                        results.BestMethodForEachPoint[i] = results.AllResults[i][j];
                    }
                }
            }
        }
        return results;
    }
    // Не нужно, до сюда не дойдёт
    return results;
}
